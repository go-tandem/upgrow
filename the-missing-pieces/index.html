<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>The Missing Pieces</title>
<meta name="description" content="Upgrow Documentation">
<link rel="stylesheet" href="/css/main.css">

  </head>

  <body>
    <nav class="navbar is-info" role="navigation" aria-label="main navigation">
  <div class="container">
    <div class="navbar-brand">
      <a class="navbar-item is-size-4 has-text-weight-semibold" href="/">
        Upgrow
      </a>

      <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false" data-target="navbarLinks">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
      </a>
    </div>

    <div id="navbarLinks" class="navbar-menu">
      <div class="navbar-start">
        <a class="navbar-item" href="/guide">
          Guide
        </a>

        <a class="navbar-item" href="/api">
          API Reference
        </a>
      </div>

      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/Shopify/upgrow" target="_blank">
          GitHub
        </a>
      </div>
    </div>
  </div>
</nav>


    <section class="section">
      <div class="container">
        
<div class="content">
  <h1 class="title is-1">The Missing Pieces</h1>

  <p>Once well defined roles are chosen for each layer of Rails, it becomes obvious that there is no answer about what category of objects should handle app-specific business logic. Controllers are responsible for HTTP, views manage formatting and presentation, and records deal with persistence. There is a big gap between these layers where the actual core piece of the app should live, agnostic of communication or databases.</p>
<p><img src="/images/diagram_2.jpg" alt="Diagram 2"></p>
<p>The cloud with questions marks above is exactly where the hard work of designing a good Rails architecture sits. That is the brain of the app, beyond simply transporting data from the database to the web via HTTP and markups. That is where the rules for permissions, validations, user flows, collaboration with other services, and everything that makes the app unique and useful to people. That is the app’s business logic.</p>
<p>The requirements for how business logic should be structured is familiar: there should be small objects that collaborate with each other through exchange of messages. Each object should have a single responsibility, a limited and concise public interface.</p>
<p>Moreover, these objects should not be coupled with Rails. The layers from the framework are already assigned other tasks related to persistence, presentation, and transport. The business logic should be decoupled from external libraries as much as possible, as it specializes in the universe the app is featured in.</p>
<p>For that, we will introduce new layers to the app stack: repositories, inputs, models, actions, and results. To better explain these concepts, let’s start with a simple example of Rails code: a classic blog app. This code is similar to the Blog example found in the Rails Guides.</p>
<p>In the example, there is one Active Record for the table of articles, with a couple of validations:</p>
<pre><code class="language-ruby"># app/models/article.rb

class Article &lt; ApplicationRecord
  validates :title, presence: true
  validates :body, presence: true, length: { minimum: 10 }
end
</code></pre>
<p>Articles Controller interacts with the Article Record to instantiate, fetch, and persist data. This code was generated by the Rails scaffold command:</p>
<pre><code class="language-ruby"># app/controllers/articles_controller.rb
class ArticlesController &lt; ApplicationController
  before_action :set_article, only: [:show, :edit, :update, :destroy]

  # GET /articles
  def index
    @articles = Article.all
  end

  # GET /articles/1
  def show
  end

  # GET /articles/new
  def new
    @article = Article.new
  end

  # GET /articles/1/edit
  def edit
  end

  # POST /articles
  def create
    @article = Article.new(article_params)

    if @article.save
      redirect_to @article, notice: 'Article was successfully created.'
    else
      render :new
    end
  end

  # PATCH/PUT /articles/1
  def update
    if @article.update(article_params)
      redirect_to @article, notice: 'Article was successfully updated.'
    else
      render :edit
    end
  end

  # DELETE /articles/1
  def destroy
    @article.destroy
    redirect_to articles_url, notice: 'Article was successfully destroyed.'
  end

  private

  # Use callbacks to share common setup or constraints between actions.
  def set_article
    @article = Article.find(params[:id])
  end

  # Only allow a list of trusted parameters through.
  def article_params
    params.require(:article).permit(:title, :body)
  end
end
</code></pre>
<p>Finally, the views invoked by Articles Controller renders instances of Article Record to list their contents, and to generate HTML forms. For example, the index view lists all Articles:</p>
<pre><code class="language-erb">&lt;p id=&quot;notice&quot;&gt;&lt;%= notice %&gt;&lt;/p&gt;

&lt;h1&gt;Articles&lt;/h1&gt;

&lt;table&gt;
 &lt;thead&gt;
   &lt;tr&gt;
     &lt;th&gt;Title&lt;/th&gt;
     &lt;th&gt;Body&lt;/th&gt;
     &lt;th colspan=&quot;3&quot;&gt;&lt;/th&gt;
   &lt;/tr&gt;
 &lt;/thead&gt;

 &lt;tbody&gt;
   &lt;% @articles.each do |article| %&gt;
     &lt;tr&gt;
       &lt;td&gt;&lt;%= article.title %&gt;&lt;/td&gt;
       &lt;td&gt;&lt;%= article.body %&gt;&lt;/td&gt;
       &lt;td&gt;&lt;%= link_to 'Show', article %&gt;&lt;/td&gt;
       &lt;td&gt;&lt;%= link_to 'Edit', edit_article_path(article) %&gt;&lt;/td&gt;
       &lt;td&gt;&lt;%= link_to 'Destroy', article, method: :delete, data: { confirm: 'Are you sure?' } %&gt;&lt;/td&gt;
     &lt;/tr&gt;
   &lt;% end %&gt;
 &lt;/tbody&gt;
&lt;/table&gt;

&lt;br&gt;

&lt;%= link_to 'New Article', new_article_path %&gt;
</code></pre>
<p>The new view, for instance, renders an HTML form to allow users to write new Articles:</p>
<pre><code class="language-erb">&lt;h1&gt;New Article&lt;/h1&gt;

&lt;%= form_with(model: @article) do |form| %&gt;
 &lt;% if @article.errors.any? %&gt;
   &lt;div id=&quot;error_explanation&quot;&gt;
     &lt;h2&gt;&lt;%= pluralize(@article.errors.count, &quot;error&quot;) %&gt; prohibited this article from being saved:&lt;/h2&gt;

     &lt;ul&gt;
       &lt;% @article.errors.each do |error| %&gt;
         &lt;li&gt;&lt;%= error.full_message %&gt;&lt;/li&gt;
       &lt;% end %&gt;
     &lt;/ul&gt;
   &lt;/div&gt;
 &lt;% end %&gt;

 &lt;div class=&quot;field&quot;&gt;
   &lt;%= form.label :title %&gt;
   &lt;%= form.text_field :title %&gt;
 &lt;/div&gt;

 &lt;div class=&quot;field&quot;&gt;
   &lt;%= form.label :body %&gt;
   &lt;%= form.text_area :body %&gt;
 &lt;/div&gt;

 &lt;div class=&quot;actions&quot;&gt;
   &lt;%= form.submit %&gt;
 &lt;/div&gt;
&lt;% end %&gt;

&lt;%= link_to 'Back', articles_path %&gt;
</code></pre>
<h2>Repositories</h2>
<p>A big subset of smells in Rails apps is found in Active Record classes. As seen previously, these objects just do way too much by default and are abused to operate both persistence and business logic roles. One of the goals of a sustainable Rails architecture is to isolate Active Record down to its basic database-related capabilities, and to keep the app’s core business logic as decoupled as possible from it. To this end a number of objects will be introduced on top of the persistence layer, starting with Repositories.</p>
<p>Repositories are responsible for the persistence layer of the app. They encapsulate Rails’ Active Record in a subset of simple methods for querying and persistence of data, and return simple read-only objects as a result. This allows the app to isolate Active Record only to this subset, exposing only the desired queries and methods to other layers through Repositories. Let’s refactor the previous example of the Blog app to encapsulate the Article Record behind a Repository.</p>
<p>As mentioned previously, Active Record objects are now referred to as simply Records. The previous Article class is now moved from app/models to app/records and renamed to Article Record.</p>
<pre><code class="language-ruby"># app/records/article_record.rb

class ArticleRecord &lt; ApplicationRecord
 self.table_name = 'articles'

 validates :title, presence: true
 validates :body, presence: true, length: { minimum: 10 }
end
</code></pre>
<p>All operations previously handled by Article Record, such as finding, creating, and deleting records are now done through Article Repository.</p>
<pre><code class="language-ruby"># app/repositories/articles_repository.rb

class ArticleRepository
 def all
   ArticleRecord.all
 end

 def create(title:, body:)
   ArticleRecord.create!(title: title, body: body)
 end

 def find(id)
   ArticleRecord.find(id)
 end

 def update(id, title:, body:)
   record = find(id)
   record.update!(title: title, body: body)
   record
 end

 def delete(id)
   record = find(id)
   record.destroy!
 end
end
</code></pre>
<pre><code class="language-ruby"># app/controllers/articles_controller.rb

class ArticlesController &lt; ApplicationController
 # GET /articles
 def index
   @articles = ArticleRepository.new.all
 end

 # GET /articles/1
 def show
   @article = ArticleRepository.new.find(params[:id])
 end

 # GET /articles/new
 def new
   @article = ArticleRecord.new
 end

 # GET /articles/1/edit
 def edit
   @article = ArticleRepository.new.find(params[:id])
 end

 # POST /articles
 def create
   @article = ArticleRepository.new.create(
     title: article_params[:title], body: article_params[:body]
   )

   redirect_to article_path(@article), notice: 'Article was successfully created.'
 rescue ActiveRecord::RecordInvalid =&gt; error
   @article = error.record
   render :new
 end

 # PATCH/PUT /articles/1
 def update
   @article = ArticleRepository.new.update(
     params[:id], title: article_params[:title], body: article_params[:body]
   )

   redirect_to article_path(@article), notice: 'Article was successfully updated.'
 rescue ActiveRecord::RecordInvalid =&gt; error
   @article = error.record
   render :edit
 end

 # DELETE /articles/1
 def destroy
   ArticleRepository.new.delete(params[:id])
   redirect_to articles_url, notice: 'Article was successfully destroyed.'
 end

 private


 # Only allow a list of trusted parameters through.
 def article_params
   params.require(:article_record).permit(:title, :body)
 end
end
</code></pre>
<p>Note, however, that Active Record is not completely encapsulated just yet. After all, the Repository still returns Record objects that controllers and views rely on in order to handle parameters and read data. These Records are used for multiple responsibilities: in some actions, such as new and edit, they represent the user’s input; in others, like in index and show, they play the role of actual persisted entities of the system. Records also hold the validation errors that might happen when a persistence operation is attempted.</p>
<p>In order to isolate Active Record completely, we must replace these cases with simpler objects for each of these responsibilities. Enter Inputs and Models.</p>
<h2>Inputs</h2>
<p>Inputs are objects that represent user-entered data. They are populated with information that is available for modification, such as in HTML forms or in API payloads, and they are passed on to Repositories as arguments for persistence operations, as provided by the app user. Inputs have knowledge about which attributes should be present in a payload, among other constraints, and are able to tell if its own state is valid or not.</p>
<p>It is important to note that Inputs differ from Records for not representing domain entities, but simply data entered by the user. Inputs do not have numeric identifiers, for example, as these are generated by the system and not set by users. There are also no strong expectations in regards to data integrity for inputs, since user-entered data can contain any information of different types, or even not to be present at all.</p>
<p>User input validation is a core part of any app’s business logic. It ensures that incoming data is sane, proper, and respects a predefined schema. A default Rails app overloads Record objects with yet another responsibility: being the place where validation rules are written and checked. While there is value in making sure that database constraints are respected, input validation should happen as part of the business logic layer, before persistence is invoked with invalid input. Input objects are a great fit for that task. By leveraging validation utilities from Active Model, Input objects can not only perform the same validations as Records but also seamlessly integrate with view helpers such as Rails form builders.</p>
<p>Let’s change the existing Blog code to use Inputs. We create the Article Input that can hold title and body, and make these the actual argument for the create and update methods in the Article Repository. We will also move the validation rules currently present in the Blog’s Article Record all the way to the Input object.</p>
<pre><code class="language-ruby"># app/inputs/article_input.rb

class ArticleInput
 include ActiveModel::Model

 attr_accessor :title, :body

 validates :title, presence: true
 validates :body, presence: true, length: { minimum: 10 }
end
</code></pre>
<pre><code class="language-ruby">class ArticleRecord &lt; ApplicationRecord
 self.table_name = 'articles'
end
</code></pre>
<pre><code class="language-ruby">class ArticleRepository
 def all
   ArticleRecord.all
 end

 def create(input)
   ArticleRecord.create!(title: input.title, body: input.body)
 end

 def find(id)
   ArticleRecord.find(id)
 end

 def update(id, input)
   record = find(id)
   record.update!(title: input.title, body: input.body)
   record
 end

 def delete(id)
   record = find(id)
   record.destroy!
 end
end
</code></pre>
<p>We can now replace the cases in which empty Article Records are used in the controller and views with the Article Input. These are also the methods that hold errors via Active Model’s Errors.</p>
<pre><code class="language-ruby">class ArticlesController &lt; ApplicationController
 # GET /articles
 def index
   @articles = ArticleRepository.new.all
 end

 # GET /articles/1
 def show
   @article = ArticleRepository.new.find(params[:id])
 end

 # GET /articles/new
 def new
   @input = ArticleInput.new
 end

 # GET /articles/1/edit
 def edit
   article = ArticleRepository.new.find(params[:id])
   @input = ArticleInput.new(title: article.title, body: article.body)
 end

 # POST /articles
 def create
   @input = ArticleInput.new(article_params)

   if @input.valid?
     article = ArticleRepository.new.create(@input)
     redirect_to article_path(article.id), notice: 'Article was successfully created.'
   else
     render :new
   end
 end

 # PATCH/PUT /articles/1
 def update
   @input = ArticleInput.new(article_params)

   if @input.valid?
     article = ArticleRepository.new.update(params[:id], @input)
     redirect_to article_path(article.id), notice: 'Article was successfully updated.'
   else
     render :edit
   end
 end

 # DELETE /articles/1
 def destroy
   ArticleRepository.new.delete(params[:id])
   redirect_to articles_url, notice: 'Article was successfully destroyed.'
 end

 private

 # Only allow a list of trusted parameters through.
 def article_params
   params.require(:article_input).permit(:title, :body)
 end
end
</code></pre>
<pre><code class="language-erb">&lt;h1&gt;New Article&lt;/h1&gt;

&lt;%= form_with(model: @input, url: articles_path) do |form| %&gt;
 &lt;% if @input.errors.present? %&gt;
   &lt;div id=&quot;error_explanation&quot;&gt;
     &lt;h2&gt;&lt;%= pluralize(@input.errors.count, &quot;error&quot;) %&gt; prohibited this article from being saved:&lt;/h2&gt;

     &lt;ul&gt;
       &lt;% @input.errors.each do |error| %&gt;
         &lt;li&gt;&lt;%= error.full_message %&gt;&lt;/li&gt;
       &lt;% end %&gt;
     &lt;/ul&gt;
   &lt;/div&gt;
 &lt;% end %&gt;

 &lt;div class=&quot;field&quot;&gt;
   &lt;%= form.label :title %&gt;
   &lt;%= form.text_field :title %&gt;
 &lt;/div&gt;

 &lt;div class=&quot;field&quot;&gt;
   &lt;%= form.label :body %&gt;
   &lt;%= form.text_area :body %&gt;
 &lt;/div&gt;

 &lt;div class=&quot;actions&quot;&gt;
   &lt;%= form.submit 'Create' %&gt;
 &lt;/div&gt;
&lt;% end %&gt;

&lt;%= link_to 'Back', articles_path %&gt;
</code></pre>
<h2>Models</h2>
<p>Models are objects that represent core entities of the app’s business logic. These are usually persisted and can be fetched and created as needed. They have unique keys for identification (usually a numeric value), and, most importantly perhaps, they are immutable. This is the key difference between this new Model layer of objects and the Active Record instances regularly referred to as models in typical Rails default apps.</p>
<p>Another difference between Models and Records is that, once instantiated, Models simply hold its attributes immutably, and they don’t have any capabilities to create or update any information in the persistence layer.</p>
<p>The collaboration between Repositories and Models is what allows Active Record to be completely hidden away from any other areas of the app. There are no references to Records in controllers, views, and anywhere else. Repositories are invoked instead, which in turn return read-only Models.</p>
<p>Let’s refactor the previous example of the Blog app to encapsulate the Article Record behind a Model and use those as return values in the Article Repository.</p>
<pre><code class="language-ruby"># app/models/article.rb

class Article
 attr_reader :id, :title, :body, :created_at, :updated_at

 def initialize(id:, title:, body:, created_at:, updated_at:)
   @id = id
   @title = title
   @body = body
  @created_at = created_at
  @updated_at = updated_at
 end
end
</code></pre>
<pre><code class="language-ruby">class ArticleRepository
 def all
   ArticleRecord.all.map { |record| to_model(record.attributes) }
 end

 def create(input)
   record = ArticleRecord.create!(title: input.title, body: input.body)
   to_model(record.attributes)
 end

 def find(id)
   record = ArticleRecord.find(id)
   to_model(record.attributes)
 end

 def update(id, input)
   record = ArticleRecord.find(id)
   record.update!(title: input.title, body: input.body)
   to_model(record.attributes)
 end

 def delete(id)
   record = ArticleRecord.find(id)
   record.destroy!
 end

 private

 def to_model(attributes)
   Article.new(**attributes.symbolize_keys)
 end
end
</code></pre>
<p>Note that since we were already using the Article Record as read-only objects, we were able to simply change the value returned by the Repository to a Model without breaking our controller and views.</p>
<h3>Actions and Results</h3>
<p>So far we have introduced new casts of objects that distribute the roles traditionally played by Active Record, decoupling the app’s business logic from Records and encapsulating them to database persistence. However, controllers are still sharing part of the responsibilities of business logic. In the Blog example, Articles Controller still sends the validate message to the input, which is a core logic that belongs to the business layer.</p>
<p>It is also important to note that in real world scenarios many other operations are involved in processing a request other than just input validation and a single call to the database. Emails are sent, jobs are enqueued, and requests to external services are performed, among others. If all this is handled at the controller level, the same smells previously explored will still be present, regardless of use of Repositories, Inputs, and Models. For those we need a boundary layer on top of the app’s business logic, so controllers can sit loosely on top of it and remain solely responsible for HTTP concerns. Enter Action objects.</p>
<p>Actions represent the entry points to the app’s core logic. These objects coordinate workflows in order to get operations and activities done. Ultimately, Actions are the public interface of the app’s business layers.</p>
<p>Rails controllers talk to the app’s internals by sending messages to specific Actions, optionally with the required inputs. Actions have a one-to-one relationship with incoming requests: they are paired symmetrically with end-user intents and demands. This is quite a special requirement from this layer: any given HTTP request handled by the app should be handled by a single Action.</p>
<p>The fact that each Action represents a meaningful and complete request-response cycle forces modularization for the app’s business logic, exposing immediately complex relationships between objects at the same time that frees up the app from scenarios such as interdependent requests. In other words, Actions do not have knowledge or coupling between other Actions whatsoever.</p>
<p>Actions respond to a single public method perform. Each Action defines its own set of required arguments for perform, as well what can be expected as the result of that method. The returned value is not any object, however. We have a special type of object dedicated to represent the outcome of an Action: Results.</p>
<p>Results are special Structs that are generated dynamically to accommodate a set of pre-defined members. Since different Actions might want to return zero to multiple values, they are always returned as members of a Result instance.</p>
<p>Regardless of the values the Action might want to return, a Result has one default member called errors, which holds any errors that might occur when the Action is performed. If Result errors are empty, the Result is a success; if there are errors present, however, the Result is a failure. This empowers Actions with a predictable public interface, so callers can expect how to evaluate if an operation was successful or not by simply checking the success or failure of a Result.</p>
<p>Additionally, Result instances behave like monadic values by offering bindings to be called only in case of success or failure, which further simplifies the caller’s code by not having to use conditional to check for errors.</p>
<p>For the sample Blog app, let’s refactor the existing code to use Actions and Results. As mentioned above, Result is a Struct with extra powers. The Result class can generate struct classes with additional members, which will allow Actions to generate custom Result Structs. Successful Results are instantiated using the success class method, which expects proper member values; failure Results are instantiated via the failure class method, receiving a collection of errors as argument.</p>
<pre><code class="language-ruby">class Result &lt; Struct
 class &lt;&lt; self
   def with_members(*members)
     new(*members, :errors, keyword_init: true)
   end

   def success(*values)
     new(*values)
   end

   def failure(errors)
     new(errors: errors)
   end
 end

 def initialize(*args)
   super(*args)
   self.errors ||= []
 end

 def and_then
   yield(*values) if errors.none?
   self
 end

 def or_else
   yield(errors) if errors.any?
   self
 end
end
</code></pre>
<p>Actions are specializations of the base Action class, which defines a few helper methods to generate Results. Each concrete Action is expected to define its own perform method thereafter and always return a Result.</p>
<pre><code class="language-ruby">class Action
 class &lt;&lt; self
   def result_class
     @result_class ||= Result.with_members(:empty)
   end

   protected

   def result(*args)
     @result_class = Result.with_members(*args)
   end
 end

 def result
   self.class.result_class
 end
end
</code></pre>
<p>We are now ready to write concrete Actions that return Results. Starting with a simple Action that finds an Article for a given ID. This Action defines its own Result as having an article member that contains the desired Article instance. Note that this Action always returns a successful Result.</p>
<pre><code class="language-ruby">class ShowArticleAction &lt; Action
 result :article

 def perform(id)
   result.success ArticleRepository.new.find(id)
 end
end

</code></pre>
<p>Here’s an example of how an Action takes an Article Input and returns an Article Result. This Action checks if the input is valid, and proceeds with calling the Repository for persistence. If the input is invalid, however, it returns a failure Result populated with the validation errors.</p>
<pre><code class="language-ruby">class CreateArticleAction &lt; Action
 result :article

 def perform(input)
   if input.valid?
     article = ArticleRepository.new.create(input)
     result.success(article: article)
   else
     result.failure(input.errors)
   end
 end
end
</code></pre>
<p>Result fields are optional. Some Actions can simply return an empty success Result as a return value, such as the Delete Article Action:</p>
<pre><code class="language-ruby">class DeleteArticleAction &lt; Action
 def perform(id)
   ArticleRepository.new.delete(id)
   result.success
 end
end
</code></pre>
<p>These Actions (and others that handle updating and listing Articles) are used in the controller as follows:</p>
<pre><code class="language-ruby">class ArticlesController &lt; ApplicationController
 # GET /articles
 def index
   @articles = ListArticlesAction.new.perform.articles
 end

 # GET /articles/1
 def show
   @article = ShowArticleAction.new.perform(params[:id]).article
 end

 # GET /articles/new
 def new
   @input = ArticleInput.new
 end

 # GET /articles/1/edit
 def edit
   article = EditArticleAction.new.perform(params[:id]).article
   @input = ArticleInput.new(title: article.title, body: article.body)
 end

 # POST /articles
 def create
   @input = ArticleInput.new(article_params)

   CreateArticleAction.new.perform(@input)
     .and_then do |article|
       redirect_to(article_path(article.id), notice: 'Article was successfully created.')
     end
     .or_else do |errors|
       render :new
     end
 end

 # PATCH/PUT /articles/1
 def update
   @input = ArticleInput.new(article_params)

   UpdateArticleAction.new.perform(params[:id], @input)
     .and_then do |article|
       redirect_to(article_path(article.id), notice: 'Article was successfully updated.')
     end
     .or_else do |errors|
       render :edit
     end
 end

 # DELETE /articles/1
 def destroy
   DeleteArticleAction.new.perform(params[:id])
   redirect_to articles_url, notice: 'Article was successfully destroyed.'
 end

 private

 # Only allow a list of trusted parameters through.
 def article_params
   params.require(:article_input).permit(:title, :body)
 end
end
</code></pre>
<p>The controller now has the single responsibility of abstracting away HTTP concerns, such as extracting data from request parameters and forwarding them to the proper Actions. According to the Result returned, the controller then crafts the appropriate HTTP response. Controllers don’t hold any logic regarding validations, persistence, or anything else behind an Action.</p>
<p><img src="/images/diagram_3.jpg" alt="Diagram 3"></p>
<p>The combination of these additional layers of Actions, Results, Inputs, Models, and Repositories allows apps to have small objects with specific roles handling the business logic. The default Rails objects are specialized in single responsibilities, and the resulting architecture is one which requests are handled by a network of objects collaborating between themselves. These objects are easy to understand, test, and most importantly, much easier to change.</p>

</div>

<div class="content">
  <nav class="pagination is-centered" role="navigation" aria-label="pagination">
    
      
    
      
    
      
    
      
    
      
    
      
        

        
          <a class="pagination-previous" href="/a-better-architecture/">Previous: A Better Architecture</a>
        

        

        
          <a class="pagination-next" href="/extensions/">Next: Extensions</a>
        
      
    
      
    
      
    
      
    
  </div>
</nav>


        <footer class="footer">
  <div class="content has-text-centered is-small">
    <p>Copyright © 2021 Shopify Inc.</p>
  </div>
</footer>

      </div>
    </section>
  </body>
</html>
